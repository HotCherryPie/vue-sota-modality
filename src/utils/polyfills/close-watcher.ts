/* eslint-disable unicorn/no-null -- justified usage */

/**
 * Mostly stolen from here:
 *  https://glitch.com/edit/#!/close-watcher-demo?path=polyfill.js
 * Spec:
 *  https://html.spec.whatwg.org/multipage/interaction.html#the-closewatcher-interface
 * Blink implementation:
 *  https://chromium.googlesource.com/chromium/src/+/refs/heads/main/third_party/blink/renderer/core/html/closewatcher/close_watcher.cc
 * WHATWG topic:
 *  https://github.com/whatwg/html/issues?q=label%3A%22topic%3A+close+watchers%22+
 */

export interface CloseWatcherEventMap {
  close: Event;

  cancel: Event;
}

interface CloseWatcher extends EventTarget {
  addEventListener: <K extends keyof CloseWatcherEventMap>(
    type: K,
    listener: (this: Document, ev: CloseWatcherEventMap[K]) => any,
  ) => void;

  removeEventListener: <K extends keyof CloseWatcherEventMap>(
    type: K,
    listener: (this: Document, ev: CloseWatcherEventMap[K]) => any,
  ) => void;

  /**
   * Acts as if a close request was sent targeting watcher, by first
   *  firing a `cancel` event, and if that event is not canceled with
   *  `preventDefault()`, proceeding to fire a `close` event before
   *  deactivating the close watcher as if `watcher.destroy()` was called.
   * This is a helper utility that can be used to consolidate cancelation
   *  and closing logic into the `cancel` and `close` event handlers,
   *  by having all non-close request closing affordances call this method.
   */
  requestClose: () => void;

  /**
   * Immediately fires the `close` event, and then deactivates the close watcher
   *  as if `watcher.destroy()` was called.
   * This is a helper utility that can be used trigger the closing logic into
   *  the `close` event handler, skipping any logic in the `cancel` event handler.
   */
  close: () => void;

  /**
   * Deactivates watcher, so that it will no longer receive close events and so
   *  that new independent CloseWatcher instances can be constructed.
   * This is intended to be called if the relevant UI element is torn down in
   *  some other way than being closed.
   */
  destroy: () => void;
}

interface CloseWatcherOptions {
  signal?: AbortSignal | undefined;
}

interface CloseWatcherConstructor {
  /**
   * Creates a new `CloseWatcher` instance.
   * If the `signal` option is provided, then watcher can be destroyed (as if by
   *  `watcher.destroy()`) by aborting the given `AbortSignal`.
   * If any close watcher is already active, and the `Window` does not have
   *  history-action activation, then the resulting `CloseWatcher` will be closed
   *  together with that already-active close watcher in response to any close
   *  request. (This already-active close watcher does not necessarily have to be
   *  a `CloseWatcher` object; it could be a modal `dialog` element, or a popover
   *  generated by an element with the `popover` attribute.)
   */
  new (options?: CloseWatcherOptions | undefined): CloseWatcher;
}

declare global {
  interface Window {
    CloseWatcher: CloseWatcherConstructor;
  }
}

export const CloseWatcher =
  globalThis.window?.CloseWatcher ??
  class CloseWatcherPolyfill extends EventTarget implements CloseWatcher {
    static readonly #closeWatcherStack: CloseWatcher[] = [];

    #keydownListenerInitialized() {
      // We only listen for Escape keydowns as close signals. The polyfill doesn't listen for anything
      // else, like Android back button presses.
      globalThis.document?.addEventListener('keydown', e => {
        if (!e.isTrusted) {
          // Not an actual user-triggered keydown.
          return;
        }

        if (e.key !== 'Escape') {
          return;
        }

        const closeWatcher = CloseWatcherPolyfill.#closeWatcherStack.at(-1);
        if (!closeWatcher) {
          return;
        }

        // Make sure all other listeners go first. Unfortunately the only way I can think of to do that is
        // to queue a task. (queueMicrotask() won't work because the microtask queue is emptied in between
        // each event listener, for browser-triggered events).
        setTimeout(() => {
          if (e.defaultPrevented) {
            // Don't deliver to the CloseWatcher; some other listener canceled the event.
            return;
          }

          closeWatcher.requestClose();
        }, 0);
      });

      return true;
    }

    #isActive = true;
    #firingCancelEvent = false;
    #oncancelHandler = null;
    #oncloseHandler = null;

    constructor({ signal }: CloseWatcherOptions = {}) {
      super();

      this.#keydownListenerInitialized();

      // We can't do the user activation checking. So sometimes in the real CloseWatcher,
      // it would be grouped with previous watchers, but we don't.

      if (signal) {
        if (signal.aborted) {
          this.#isActive = false;
          return;
        }
        signal.addEventListener('abort', () => void this.#deactivate());
      }

      CloseWatcherPolyfill.#closeWatcherStack.push(this);
    }

    destroy() {
      this.#deactivate();
    }

    close() {
      if (!this.#isActive || !document.defaultView) {
        return;
      }

      this.dispatchEvent(new Event('close'));

      this.#deactivate();
    }

    requestClose() {
      if (!this.#isActive) {
        return;
      }
      if (this.#firingCancelEvent) {
        return;
      }

      // We can't do the user activation checking. So sometimes in the real CloseWatcher, the cancel
      // event would get skipped, but in the polyfill, we always fire it.

      this.#firingCancelEvent = true;
      const shouldContinue = this.dispatchEvent(
        new Event('cancel', { cancelable: true }),
      );
      this.#firingCancelEvent = false;
      if (!shouldContinue) {
        return;
      }

      if (this.#isActive && document.defaultView) {
        this.dispatchEvent(new Event('close'));
      }
      this.#deactivate();
    }

    #deactivate() {
      this.#isActive = false;

      // Might not be the top of the stack if we're using destroy().
      const index = CloseWatcherPolyfill.#closeWatcherStack.indexOf(this);
      if (index !== -1) {
        CloseWatcherPolyfill.#closeWatcherStack.splice(index, 1);
      }
    }

    get oncancel() {
      return this.#oncancelHandler;
    }
    set oncancel(handler) {
      if (handler !== this.#oncancelHandler || handler === null) {
        this.removeEventListener('cancel', this.#oncancelHandler);
        this.#oncancelHandler = null;
        return;
      }

      this.#oncancelHandler = handler;
      this.addEventListener('cancel', this.#oncancelHandler);
    }

    get onclose() {
      return this.#oncancelHandler;
    }
    set onclose(handler) {
      if (handler !== this.#oncloseHandler || handler === null) {
        this.removeEventListener('close', this.#oncloseHandler);
        this.#oncloseHandler = null;
        return;
      }

      this.#oncloseHandler = handler;
      this.addEventListener('close', this.#oncloseHandler);
    }
  };
