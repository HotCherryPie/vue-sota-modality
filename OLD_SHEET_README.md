# Modal

## TODO

- `runOnActive`

## Архитектура

### Глоссарий

- _Компонент-портал_ (`ModalLayout`) — компонент внутрь которого будут помещены все открытые модалки.
- _Компонент-клиент_ — компонент, который реализует конкретное модальное окно (например модалка авторизации).
- _Компонент-обертка_ — компонент инкапсулирующий в себе типовой дизайн и логику модальных окон. В рамках ui-кита сейчас доступен только `Modal`. Однако никаких ограничений на то, какой _компонент-обертку_ должен _компонент-клиент_ и должен ли вообще его использовать, нет.
- **_Modal value_** (не путать с `modelValue`!) — основное/центральное значение модалки, выбор/изменение которого представляет основную цель его существования.
- **_Modal data_** — любые другие данные, которые могут потребоваться для работы щита.

### Требования

При разработке были сформированы и учтены следующие требования:

- Использование _компонентов-оберток_ не должно быть обязательным условием при реализации модального окна. Пользователь должен всегда иметь возможность создать свое уникальное модальное окно, со своим уникальным дизайном, полагаясь исключительно на контракт определенный _компонентом-порталом_.
- Типовых дизайнов модалок может быть больше, чем один (тот который представлен в актуальном ките). Условный стрим казино должен при желании иметь возможность в рамках своей кодовой базы сделать свой _компонент-обертку_ и использовать его в рамках своих _компонентов-клиентов_.
- _Компоненты-обертки_ и _компонент-клиенты_ не должны иметь жесткой связанности с _компонентом-порталом_. Взаимодействие должно быть исключительно в рамках очень ограниченного и простого в реализации/обслуживании контракта.
  - Факт полной или частичной реализации контракта не должен быть обязательным условием для _компонента-клиента_. Из чего следует, что технически должно быть возможно открыть в рамках _компоненты-портала_ абсолютно любой компонент.
- _Компонент-портал_ не должен ни коим образом влиять на то, как будут отображены _компоненты-клиенты_ или _компоненты-обертки_. В частности, в это входит:
  - Блокировка скрола
  - Анимацией появления/скрытия модалки
  - Отображением подложки
  - Ограничение размера модального окна
  - Определение отступов модального окна
  - Определение того, что должно являться причиной закрытия окна со стороны пользователя (нажатие браузерной кнопки «**Назад**» или нажатие кнопки <kbd>esc</kbd> на клавиатуре)

### Контракт

Компонент-портал:

- Учитывает `v-model` _компонента-клиента_, считая это значение как **modal value** .
- Передает в _компонент-клиент_ пропсу `data` значение **modal data**
- Передает в _компонент-клиент_ пропсу `dismissCallTrigger` числовое значение, которое меняется каждый раз, когда клиентский код запрашивает закрытие окна.
- Считает событие `close` полученное от _компонента-клиента_, как запрос на закрытие.
  - Если значение события `CustomEvent` и `.detail` является `Promise` — закрытие произойдет после резолва данного промиса.
  - Если значение события `Promise` — закрытие произойдет после резолва данного промиса.
  - Во всех остальных случаях закрытие происходит моментально;

## Использование

**1\.** Для начала надо расположить компонент `ModalLayout` где-то в корне приложения. Например:

`src/app.vue`

```vue
<template>
  <div id="app">
    ...

    <!-- Например вот тут -->
    <ModalLayout />
  </div>
</template>
```

Все наши открытые модалки будут помещены именно в него.

**2\.** Дальше надо создать компонент модалки.

**Пример с примитивной модалкой:**
`src/modals/my-simple-modal.vue`

```vue
<template>
  <Modal>
    <template #default="{ dismiss }">
      ...
      <button @click="dismiss('cancel')">Close modal</button>
      ...
    </template>
  </Modal>
</template>

<script setup lang="ts">
import { Modal } from 'ui-kit';
</script>
```

Для большинства модальных окон подобного сетапа будет более чем достаточно.

**Пример с комплексной модалкой:**

`src/modals/my-complex-modal.vue`

Если нам надо передать **modal value** и/или **modal data**, то сетап стане чуть сложнее.

```vue
<template>
  <Modal>
    <template #default="{ dismiss }">
      <h3>{{ data.label }}</h3>
      ...
      <button @click="dismiss('cancel')">Close modal</button>
      ...
      <button @click="$emit('update:modelValue', 1)">Select 1</button>
      <button @click="$emit('update:modelValue', 2)">Select 2</button>
    </template>
  </Modal>
</template>

<script setup lang="ts">
import { Modal, ModalLayoutChildProps, ModalLayoutChildEmits } from 'ui-kit';

type Value = string;
type Data = { label: string };

defineProps<ModalLayoutChildProps<Data, Value>>();
defineEmits<ModalLayoutChildEmits<Value>>();
</script>
```

**3\.** Открытие/закрытие/использование модалки

Теперь, когда мы создали компоненты наших модальных окон, самое время ими воспользоваться. Для этого нам монадобится хук `useModal`:

```ts
import { useModal } from 'ui-kit';
import MySimpleModal from '@/modals/my-simple-modal.vue';

const { open } = useModal(MySimpleModal);

function handleClick() {
  open();
}
```

> #### Внимание!
>
> Повторные вызовы `open()` не будут иметь эффекта. Если вы хотите в уже открытую модалку передать новое значение **_modal data_**, то стоит сразу передавать реактивное значение (`ref`/`reactive`). В таком случае реактивность данных будет сохранена.

При необходимости мы также можем программно закрыть модалку

```ts
const { open, close } = useModal(MySimpleModal);

function handleClick() {
  close();
}
```

`useModal` также принимает несколько опций:

- `dismissOnScopeDispose: boolean` — Если указать `true` (_стандартное значение_), то модалка будет автоматически закрыта при диспозе активного скопа. Обычно это значит, что при анмаунте компонента `close()` буде вызван автоматически, а значит писать что-то вроде `beforeUnmount(() => close())` смысла нет.
- `dismissOnValueChange: boolean` — Если указать `true` (_стандартное значение_), то модалка будет автоматически закрыта при изменении `value`.

**Использование с _modal data_ и _modal value_**

```ts
import { useModal } from 'ui-kit';
import MySimpleModal from '@/modals/my-complex-modal.vue';

// Этот реф будет нашим "modal value"
const selectedOption = ref(1);

const { open } = useModal(MySimpleModal, {
  value: selectedOption,
});

function handleClick() {
  // -
  open({ label: 'Hello' });
}
```

Благодаря тому, что в компоненте `my-complex-modal.vue` мы с помощью `ModalLayoutChildProps` `ModalLayoutChildEmits` указали типы для наших **_modal value_** и **_modal data_**, мы получаем типизацию для свойства `value` и аргумента в `open`

![usage example](/uploads/064e85631c3264f7283c0ac5d2eb51e3/3.png)

## Поддержка

Т.к. в нынешнем дизайне модалки представляет собой то, что в современной традиции UI дизайна называется «Sheet»/«Щит», то именно такой терми будет использоваться дальше.

#### Глоссарий

- **Detent** — высота, которую занимает щит
- **Fling** — действие быстрого одергивания щита вниз, ради его закрытия.
- **Tongue** — маленький индикатор в самом верху щита, который служит для индикации того, что щитом можно манипулировать жестом.
- **Backdrop** — Обычно это либо размытие или затемнение.
- **Pinafore** — Часть щита, единственное предназначение которой в том, чтобы растянуть фон щита за пределы вьюпорта. Актуально только для мобильной версии, которая выезжает снизу экрана, и снапится к нему. Необходимость в нем есть, т.к. навигационные панели браузеров зачастую не полностью скрывают контент по собой, а применяют к нему размытие и/или затемнение, и из-за этого пользователь будет видеть под навигационной панелью контент страницы, а не фон щита, что создает _прецедент крайне разочаровывающего эстетического кринжа_, который абсолютно неприемлем!

### Десктопный щит `modal/desktop-modal.vue`

Сейчас тут ничего интересного нет. Просто белый прямоугольник с некоторыми ограничениями по размерам.

### Мобильный щит `modal/mobile-modal.vue`

#### Анатомия мобильного модального окна

![modal anatomy](/uploads/f9389ad37fa21c88973f5cd66851b366/image.png)

#### Нюансы реализации

Есть несколько моментов, которые стоит учитывать при проектировании/реализации/тестировании щитов:

- _Layout Viewport_ изменить свои размеры в любой момент жизненного цикла щита, включая момент, когда пользователь в процессе перетаскивания щита.
- Щиты с авто **detent** могут изменить свой размер (из-за изменения размера контента) в любой момент жизненного цикла щита, включая момент, когда пользователь в процессе перетаскивания щита, а также в момент открытия/закрытия щита. Это событие не должно быть причиной гличей в анимации и снаппинге щита к пальцу пользователя.
- Пользователь может поймать щит во время анимации появления, и это событие должно быть корректно обработано.
- Во время анимации закрытия щита, контент щита должен быть недоступен для взаимодействия, чтобы предостеречь пользователя от совершения нежелательных действий. Тоже самое касается контента под щитом, т.к. если случится пролаг., и пользователь сделает несколько кликов по условному крестику, то эти клики потом полетят в контент по щитом, что будет неожиданным для пользователя поведением. Тут же стоит отметить, что скролл контента по щитом в идеале должен быть доступен еще до завершения анимации закрытия, чтобы не заставлять пользователя ждать.
